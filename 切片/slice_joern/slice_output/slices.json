[
  {
    "project": "ffmpeg-6.1.1",
    "file": "libavcodec/motion_est_template.c",
    "line": 785,
    "status": "success",
    "function_name": "var_diamond_search",
    "function_start_line": 771,
    "function_end_line": 830,
    "sliced_code": "static\nint\nvar_diamond_search\n(\nMpegEncContext * s\n,\nint *best\n,\nint dmin\n,\nMotionEstContext * const c= &s->me;\nLOAD_COMMON\n    LOAD_COMMON2\nunsigned map_generation = c->map_generation;\nfor\n(\ndia_size=1\n;\ndia_size<=c->dia_size\n;\ndia_size++\n)\n{\nconst int x= best[0];\nconst int y= best[1];\nstart= FFMAX(0, y + dia_size - ymax);\nend  = FFMIN(dia_size, xmax - x + 1);\nfor\n(\ndir= start\n;\ndir<end\n;\ndir++\n)\n{\nCHECK_MV(x + dir           , y + dia_size - dir);\nstart= FFMAX(0, x + dia_size - xmax);\nend  = FFMIN(dia_size, y - ymin + 1);\nfor\n(\ndir= start\n;\ndir<end\n;\ndir++\n)\n{\nCHECK_MV(x + dia_size - dir, y - dir           );\nstart= FFMAX(0, -y + dia_size + ymin );\nend  = FFMIN(dia_size, x - xmin + 1);\nfor\n(\ndir= start\n;\ndir<end\n;\ndir++\n)\n{\nCHECK_MV(x - dir           , y - dia_size + dir);\nstart= FFMAX(0, -x + dia_size + xmin );\nend  = FFMIN(dia_size, ymax - y + 1);\nfor\n(\ndir= start\n;\ndir<end\n;\ndir++\n)\n{\nCHECK_MV(x - dia_size + dir, y + dir           );\nif(x!=best[0] || y!=best[1])\n            dia_size=0;\nreturn dmin;",
    "slice_lines": [
      771,
      775,
      778,
      779,
      780,
      785,
      787,
      788,
      790,
      791,
      792,
      796,
      799,
      800,
      801,
      805,
      808,
      809,
      810,
      814,
      817,
      818,
      819,
      823,
      826,
      827,
      829
    ],
    "metadata": {
      "function_name": "var_diamond_search",
      "function_start_line": 771,
      "function_end_line": 830,
      "target_line": 785,
      "backward_nodes": 80,
      "forward_nodes": 323,
      "total_slice_nodes": 403,
      "total_slice_lines": 27,
      "slice_density": 0.45,
      "final_node_count": 375
    }
  },
  {
    "project": "ffmpeg-6.1.1",
    "file": "libavcodec/mpegaudioenc_template.c",
    "line": 199,
    "status": "success",
    "function_name": "idct32",
    "function_start_line": 198,
    "function_end_line": 315,
    "sliced_code": "",
    "slice_lines": [],
    "metadata": {
      "total_slice_lines": 0,
      "final_node_count": 0
    }
  },
  {
    "project": "ffmpeg-6.1.1",
    "file": "libavcodec/smc.c",
    "line": 137,
    "status": "success",
    "function_name": "smc_decode_stream",
    "function_start_line": 76,
    "function_end_line": 408,
    "sliced_code": "static\nint\nsmc_decode_stream(SmcContext *s, GetByteContext *gb)\nint image_size = height * s->frame->linesize[0];\nint row_ptr = 0;\nbytestream2_skip(gb, 1);\nchunk_size = bytestream2_get_be24(gb);\nwhile\n(total_blocks)\n{\nif\n(row_ptr >= image_size)\n{\nav_log\n(\ns->avctx\n,\nAV_LOG_ERROR\n,\n\"just went out of bounds (row ptr = %d, height = %d)\\n\"\n,\nreturn AVERROR_INVALIDDATA;\nif\n(bytestream2_get_bytes_left(gb) < 1)\n{\nav_log(s->avctx, AV_LOG_ERROR, \"input too small\\n\");\nreturn AVERROR_INVALIDDATA;\nopcode = bytestream2_get_byteu(gb);\nswitch\n(opcode & 0xF0)\n{\nn_blocks = GET_BLOCK_COUNT();\nwhile\n(n_blocks--)\n{\nADVANCE_BLOCK();\nn_blocks = GET_BLOCK_COUNT();\nif\n((row_ptr == 0) && (pixel_ptr == 0))\n{\nav_log(s->avctx, AV_LOG_ERROR, \"encountered repeat block opcode (%02X) but no blocks rendered yet\\n\",\n                    opcode & 0xF0);\nreturn AVERROR_INVALIDDATA;\nif\n(pixel_ptr == 0)\nprev_block_ptr1 =\n                    (row_ptr - s->avctx->width * 4) + s->avctx->width - 4;\nprev_block_ptr1 = row_ptr + pixel_ptr - 4;\nwhile\n(n_blocks--)\n{\nblock_ptr = row_ptr + pixel_ptr;\nprev_block_ptr = prev_block_ptr1;\nfor\n(\npixel_y = 0\n;\npixel_y < 4\n;\npixel_y++\n)\n{\nfor\n(\npixel_x = 0\n;\npixel_x < 4\n;\npixel_x++\n)\n{\npixels[block_ptr++] = pixels[prev_block_ptr++];\nblock_ptr += row_inc;\nprev_block_ptr += row_inc;\nADVANCE_BLOCK();\nn_blocks = GET_BLOCK_COUNT();\nn_blocks *= 2;\nif\n((row_ptr == 0) && (pixel_ptr < 2 * 4))\n{\nav_log(s->avctx, AV_LOG_ERROR, \"encountered repeat block opcode (%02X) but not enough blocks rendered yet\\n\",\n                    opcode & 0xF0);\nreturn AVERROR_INVALIDDATA;\nif\n(pixel_ptr == 0)\nprev_block_ptr1 = (row_ptr - s->avctx->width * 4) +\n                    s->avctx->width - 4 * 2;\nelse\nif\n(pixel_ptr == 4)\nprev_block_ptr1 = (row_ptr - s->avctx->width * 4) + row_inc;\nprev_block_ptr1 = row_ptr + pixel_ptr - 4 * 2;\nif\n(pixel_ptr == 0)\nprev_block_ptr2 = (row_ptr - s->avctx->width * 4) + row_inc;\nprev_block_ptr2 = row_ptr + pixel_ptr - 4;\nprev_block_flag = 0;\nwhile\n(n_blocks--)\n{\nblock_ptr = row_ptr + pixel_ptr;\nif\n(prev_block_flag)\nprev_block_ptr = prev_block_ptr2;\nprev_block_ptr = prev_block_ptr1;\nprev_block_flag = !prev_block_flag;\nfor\n(\npixel_y = 0\n;\npixel_y < 4\n;\npixel_y++\n)\n{\nfor\n(\npixel_x = 0\n;\npixel_x < 4\n;\npixel_x++\n)\n{\npixels[block_ptr++] = pixels[prev_block_ptr++];\nblock_ptr += row_inc;\nprev_block_ptr += row_inc;\nADVANCE_BLOCK();\nn_blocks = GET_BLOCK_COUNT();\npixel = bytestream2_get_byte(gb);\nwhile\n(n_blocks--)\n{\nblock_ptr = row_ptr + pixel_ptr;\nfor\n(\npixel_y = 0\n;\npixel_y < 4\n;\npixel_y++\n)\n{\nfor\n(\npixel_x = 0\n;\npixel_x < 4\n;\npixel_x++\n)\n{\npixels[block_ptr++] = pixel;\nblock_ptr += row_inc;\nADVANCE_BLOCK();\nn_blocks = (opcode & 0x0F) + 1;\nif\n((opcode & 0xF0) == 0x80)\n{\nfor\n(\ni = 0\n;\ni < CPAIR\n;\ni++\n)\n{\npixel = bytestream2_get_byte(gb);\ncolor_table_index = CPAIR * color_pair_index + i;\ns->color_pairs[color_table_index] = pixel;\ncolor_table_index = CPAIR * color_pair_index;\ncolor_pair_index++;\nif (color_pair_index == COLORS_PER_TABLE)\n                    color_pair_index = 0;\ncolor_table_index = CPAIR * bytestream2_get_byte(gb);\nwhile\n(n_blocks--)\n{\ncolor_flags = bytestream2_get_be16(gb);\nflag_mask = 0x8000;\nblock_ptr = row_ptr + pixel_ptr;\nfor\n(\npixel_y = 0\n;\npixel_y < 4\n;\npixel_y++\n)\n{\nfor\n(\npixel_x = 0\n;\npixel_x < 4\n;\npixel_x++\n)\n{\nif\n(color_flags & flag_mask)\npixel = color_table_index + 1;\npixel = color_table_index;\nflag_mask >>= 1;\npixels[block_ptr++] = s->color_pairs[pixel];\nblock_ptr += row_inc;\nADVANCE_BLOCK();\nn_blocks = (opcode & 0x0F) + 1;\nif\n((opcode & 0xF0) == 0xA0)\n{\nfor\n(\ni = 0\n;\ni < CQUAD\n;\ni++\n)\n{\npixel = bytestream2_get_byte(gb);\ncolor_table_index = CQUAD * color_quad_index + i;\ns->color_quads[color_table_index] = pixel;\ncolor_table_index = CQUAD * color_quad_index;\ncolor_quad_index++;\nif (color_quad_index == COLORS_PER_TABLE)\n                    color_quad_index = 0;\ncolor_table_index = CQUAD * bytestream2_get_byte(gb);\nwhile\n(n_blocks--)\n{\ncolor_flags = bytestream2_get_be32(gb);\nflag_mask = 30;\nblock_ptr = row_ptr + pixel_ptr;\nfor\n(\npixel_y = 0\n;\npixel_y < 4\n;\npixel_y++\n)\n{\nfor\n(\npixel_x = 0\n;\npixel_x < 4\n;\npixel_x++\n)\n{\npixel = color_table_index +\n                            ((color_flags >> flag_mask) & 0x03);\nflag_mask -= 2;\npixels[block_ptr++] = s->color_quads[pixel];\nblock_ptr += row_inc;\nADVANCE_BLOCK();\nn_blocks = (opcode & 0x0F) + 1;\nif\n((opcode & 0xF0) == 0xC0)\n{\nfor\n(\ni = 0\n;\ni < COCTET\n;\ni++\n)\n{\npixel = bytestream2_get_byte(gb);\ncolor_table_index = COCTET * color_octet_index + i;\ns->color_octets[color_table_index] = pixel;\ncolor_table_index = COCTET * color_octet_index;\ncolor_octet_index++;\nif (color_octet_index == COLORS_PER_TABLE)\n                    color_octet_index = 0;\ncolor_table_index = COCTET * bytestream2_get_byte(gb);\nwhile\n(n_blocks--)\n{\nint val1 = bytestream2_get_be16(gb);\nint val2 = bytestream2_get_be16(gb);\nint val3 = bytestream2_get_be16(gb);\ncolor_flags_a = ((val1 & 0xFFF0) << 8) | (val2 >> 4);\ncolor_flags_b = ((val3 & 0xFFF0) << 8) |\n                    ((val1 & 0x0F) << 8) | ((val2 & 0x0F) << 4) | (val3 & 0x0F);\ncolor_flags = color_flags_a;\nflag_mask = 21;\nblock_ptr = row_ptr + pixel_ptr;\nfor\n(\npixel_y = 0\n;\npixel_y < 4\n;\npixel_y++\n)\n{\nif\n(pixel_y == 2)\n{\ncolor_flags = color_flags_b;\nflag_mask = 21;\nfor\n(\npixel_x = 0\n;\npixel_x < 4\n;\npixel_x++\n)\n{\npixel = color_table_index +\n                            ((color_flags >> flag_mask) & 0x07);\nflag_mask -= 3;\npixels[block_ptr++] = s->color_octets[pixel];\nblock_ptr += row_inc;\nADVANCE_BLOCK();\nn_blocks = (opcode & 0x0F) + 1;\nwhile\n(n_blocks--)\n{\nblock_ptr = row_ptr + pixel_ptr;\nfor\n(\npixel_y = 0\n;\npixel_y < 4\n;\npixel_y++\n)\n{\nfor\n(\npixel_x = 0\n;\npixel_x < 4\n;\npixel_x++\n)\n{\npixels[block_ptr++] = bytestream2_get_byte(gb);\nblock_ptr += row_inc;\nADVANCE_BLOCK();\nreturn 0;",
    "slice_lines": [
      76,
      93,
      94,
      113,
      114,
      123,
      126,
      127,
      129,
      131,
      132,
      133,
      136,
      137,
      141,
      142,
      143,
      150,
      153,
      154,
      155,
      156,
      160,
      161,
      162,
      164,
      166,
      167,
      168,
      169,
      170,
      171,
      173,
      174,
      176,
      183,
      184,
      187,
      188,
      189,
      190,
      194,
      195,
      196,
      197,
      198,
      200,
      202,
      203,
      205,
      207,
      208,
      209,
      210,
      211,
      213,
      214,
      216,
      217,
      218,
      220,
      221,
      223,
      230,
      231,
      233,
      234,
      235,
      236,
      237,
      239,
      241,
      248,
      251,
      254,
      255,
      256,
      257,
      260,
      261,
      263,
      264,
      266,
      268,
      269,
      270,
      271,
      272,
      273,
      274,
      275,
      277,
      278,
      279,
      281,
      283,
      290,
      293,
      296,
      297,
      298,
      299,
      302,
      303,
      305,
      306,
      308,
      310,
      311,
      313,
      314,
      315,
      316,
      317,
      318,
      319,
      320,
      322,
      324,
      331,
      334,
      337,
      338,
      339,
      340,
      343,
      344,
      346,
      347,
      349,
      351,
      359,
      360,
      361,
      362,
      363,
      364,
      366,
      368,
      369,
      370,
      372,
      373,
      374,
      376,
      377,
      378,
      379,
      380,
      382,
      384,
      391,
      393,
      394,
      395,
      396,
      397,
      399,
      401,
      407
    ],
    "metadata": {
      "function_name": "smc_decode_stream",
      "function_start_line": 76,
      "function_end_line": 408,
      "target_line": 137,
      "backward_nodes": 84,
      "forward_nodes": 474,
      "total_slice_nodes": 558,
      "total_slice_lines": 160,
      "slice_density": 0.4804804804804805,
      "final_node_count": 536
    }
  }
]