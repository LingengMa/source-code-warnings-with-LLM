[
  {
    "project": "ffmpeg-6.1.1",
    "file": "libavcodec/motion_est_template.c",
    "line": 785,
    "status": "success",
    "function_name": "var_diamond_search",
    "function_start_line": 771,
    "function_end_line": 830,
    "sliced_code": "static int var_diamond_search(MpegEncContext * s, int *best, int dmin,\n    MotionEstContext * const c= &s->me;\n    LOAD_COMMON\n    LOAD_COMMON2\n    unsigned map_generation = c->map_generation;\n    for(dia_size=1; dia_size<=c->dia_size; dia_size++){ // CRITERION_LINE\n        const int x= best[0];\n        const int y= best[1];\n        start= FFMAX(0, y + dia_size - ymax);\n        end  = FFMIN(dia_size, xmax - x + 1);\n        for(dir= start; dir<end; dir++){\n            CHECK_MV(x + dir           , y + dia_size - dir);\n        start= FFMAX(0, x + dia_size - xmax);\n        end  = FFMIN(dia_size, y - ymin + 1);\n        for(dir= start; dir<end; dir++){\n            CHECK_MV(x + dia_size - dir, y - dir           );\n        start= FFMAX(0, -y + dia_size + ymin );\n        end  = FFMIN(dia_size, x - xmin + 1);\n        for(dir= start; dir<end; dir++){\n            CHECK_MV(x - dir           , y - dia_size + dir);\n        start= FFMAX(0, -x + dia_size + xmin );\n        end  = FFMIN(dia_size, ymax - y + 1);\n        for(dir= start; dir<end; dir++){\n            CHECK_MV(x - dia_size + dir, y + dir           );\n        if(x!=best[0] || y!=best[1])\n            dia_size=0;\n    return dmin;",
    "slice_lines": [
      771,
      775,
      778,
      779,
      780,
      785,
      787,
      788,
      790,
      791,
      792,
      796,
      799,
      800,
      801,
      805,
      808,
      809,
      810,
      814,
      817,
      818,
      819,
      823,
      826,
      827,
      829
    ],
    "metadata": {
      "original_data": {
        "tool_name": "codeql",
        "project_name": "ffmpeg",
        "project_name_with_version": "ffmpeg-6.1.1",
        "project_version": "6.1.1",
        "file_path": "libavcodec/motion_est_template.c",
        "line_number": 785,
        "cwe": null,
        "rule_id": "cpp/complex-block",
        "message": "Block with too many statements (4 complex statements in the block).",
        "severity": null
      },
      "function_name": "var_diamond_search",
      "function_start_line": 771,
      "function_end_line": 830,
      "target_line": 785,
      "backward_nodes": 80,
      "forward_nodes": 323,
      "total_slice_nodes": 403,
      "total_slice_lines": 27,
      "slice_density": 0.45,
      "final_node_count": 375
    }
  },
  {
    "project": "ffmpeg-6.1.1",
    "file": "libavcodec/mpegaudioenc_template.c",
    "line": 199,
    "status": "success",
    "function_name": "idct32",
    "function_start_line": 198,
    "function_end_line": 315,
    "sliced_code": "",
    "slice_lines": [],
    "metadata": {
      "original_data": {
        "tool_name": "codeql",
        "project_name": "ffmpeg",
        "project_name_with_version": "ffmpeg-6.1.1",
        "project_version": "6.1.1",
        "file_path": "libavcodec/mpegaudioenc_template.c",
        "line_number": 199,
        "cwe": null,
        "rule_id": "cpp/complex-block",
        "message": "Block with too many statements (4 complex statements in the block).",
        "severity": null
      },
      "total_slice_lines": 0,
      "final_node_count": 0
    }
  },
  {
    "project": "ffmpeg-6.1.1",
    "file": "libavcodec/smc.c",
    "line": 137,
    "status": "success",
    "function_name": "smc_decode_stream",
    "function_start_line": 76,
    "function_end_line": 408,
    "sliced_code": "static int smc_decode_stream(SmcContext *s, GetByteContext *gb)\n    int image_size = height * s->frame->linesize[0];\n    int row_ptr = 0;\n    bytestream2_skip(gb, 1);\n    chunk_size = bytestream2_get_be24(gb);\n    while (total_blocks) {\n        if (row_ptr >= image_size) {\n            av_log(s->avctx, AV_LOG_ERROR, \"just went out of bounds (row ptr = %d, height = %d)\\n\",\n            return AVERROR_INVALIDDATA;\n        if (bytestream2_get_bytes_left(gb) < 1) {\n            av_log(s->avctx, AV_LOG_ERROR, \"input too small\\n\");\n            return AVERROR_INVALIDDATA;\n        opcode = bytestream2_get_byteu(gb);\n        switch (opcode & 0xF0) { // CRITERION_LINE\n            n_blocks = GET_BLOCK_COUNT();\n            while (n_blocks--) {\n                ADVANCE_BLOCK();\n            n_blocks = GET_BLOCK_COUNT();\n            if ((row_ptr == 0) && (pixel_ptr == 0)) {\n                av_log(s->avctx, AV_LOG_ERROR, \"encountered repeat block opcode (%02X) but no blocks rendered yet\\n\",\n                    opcode & 0xF0);\n                return AVERROR_INVALIDDATA;\n            if (pixel_ptr == 0)\n                prev_block_ptr1 =\n                    (row_ptr - s->avctx->width * 4) + s->avctx->width - 4;\n                prev_block_ptr1 = row_ptr + pixel_ptr - 4;\n            while (n_blocks--) {\n                block_ptr = row_ptr + pixel_ptr;\n                prev_block_ptr = prev_block_ptr1;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++) {\n                        pixels[block_ptr++] = pixels[prev_block_ptr++];\n                    block_ptr += row_inc;\n                    prev_block_ptr += row_inc;\n                ADVANCE_BLOCK();\n            n_blocks = GET_BLOCK_COUNT();\n            n_blocks *= 2;\n            if ((row_ptr == 0) && (pixel_ptr < 2 * 4)) {\n                av_log(s->avctx, AV_LOG_ERROR, \"encountered repeat block opcode (%02X) but not enough blocks rendered yet\\n\",\n                    opcode & 0xF0);\n                return AVERROR_INVALIDDATA;\n            if (pixel_ptr == 0)\n                prev_block_ptr1 = (row_ptr - s->avctx->width * 4) +\n                    s->avctx->width - 4 * 2;\n            else if (pixel_ptr == 4)\n                prev_block_ptr1 = (row_ptr - s->avctx->width * 4) + row_inc;\n                prev_block_ptr1 = row_ptr + pixel_ptr - 4 * 2;\n            if (pixel_ptr == 0)\n                prev_block_ptr2 = (row_ptr - s->avctx->width * 4) + row_inc;\n                prev_block_ptr2 = row_ptr + pixel_ptr - 4;\n            prev_block_flag = 0;\n            while (n_blocks--) {\n                block_ptr = row_ptr + pixel_ptr;\n                if (prev_block_flag)\n                    prev_block_ptr = prev_block_ptr2;\n                    prev_block_ptr = prev_block_ptr1;\n                prev_block_flag = !prev_block_flag;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++) {\n                        pixels[block_ptr++] = pixels[prev_block_ptr++];\n                    block_ptr += row_inc;\n                    prev_block_ptr += row_inc;\n                ADVANCE_BLOCK();\n            n_blocks = GET_BLOCK_COUNT();\n            pixel = bytestream2_get_byte(gb);\n            while (n_blocks--) {\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++) {\n                        pixels[block_ptr++] = pixel;\n                    block_ptr += row_inc;\n                ADVANCE_BLOCK();\n            n_blocks = (opcode & 0x0F) + 1;\n            if ((opcode & 0xF0) == 0x80) {\n                for (i = 0; i < CPAIR; i++) {\n                    pixel = bytestream2_get_byte(gb);\n                    color_table_index = CPAIR * color_pair_index + i;\n                    s->color_pairs[color_table_index] = pixel;\n                color_table_index = CPAIR * color_pair_index;\n                color_pair_index++;\n                if (color_pair_index == COLORS_PER_TABLE)\n                    color_pair_index = 0;\n                color_table_index = CPAIR * bytestream2_get_byte(gb);\n            while (n_blocks--) {\n                color_flags = bytestream2_get_be16(gb);\n                flag_mask = 0x8000;\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++) {\n                        if (color_flags & flag_mask)\n                            pixel = color_table_index + 1;\n                            pixel = color_table_index;\n                        flag_mask >>= 1;\n                        pixels[block_ptr++] = s->color_pairs[pixel];\n                    block_ptr += row_inc;\n                ADVANCE_BLOCK();\n            n_blocks = (opcode & 0x0F) + 1;\n            if ((opcode & 0xF0) == 0xA0) {\n                for (i = 0; i < CQUAD; i++) {\n                    pixel = bytestream2_get_byte(gb);\n                    color_table_index = CQUAD * color_quad_index + i;\n                    s->color_quads[color_table_index] = pixel;\n                color_table_index = CQUAD * color_quad_index;\n                color_quad_index++;\n                if (color_quad_index == COLORS_PER_TABLE)\n                    color_quad_index = 0;\n                color_table_index = CQUAD * bytestream2_get_byte(gb);\n            while (n_blocks--) {\n                color_flags = bytestream2_get_be32(gb);\n                flag_mask = 30;\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++) {\n                        pixel = color_table_index +\n                            ((color_flags >> flag_mask) & 0x03);\n                        flag_mask -= 2;\n                        pixels[block_ptr++] = s->color_quads[pixel];\n                    block_ptr += row_inc;\n                ADVANCE_BLOCK();\n            n_blocks = (opcode & 0x0F) + 1;\n            if ((opcode & 0xF0) == 0xC0) {\n                for (i = 0; i < COCTET; i++) {\n                    pixel = bytestream2_get_byte(gb);\n                    color_table_index = COCTET * color_octet_index + i;\n                    s->color_octets[color_table_index] = pixel;\n                color_table_index = COCTET * color_octet_index;\n                color_octet_index++;\n                if (color_octet_index == COLORS_PER_TABLE)\n                    color_octet_index = 0;\n                color_table_index = COCTET * bytestream2_get_byte(gb);\n            while (n_blocks--) {\n                int val1 = bytestream2_get_be16(gb);\n                int val2 = bytestream2_get_be16(gb);\n                int val3 = bytestream2_get_be16(gb);\n                color_flags_a = ((val1 & 0xFFF0) << 8) | (val2 >> 4);\n                color_flags_b = ((val3 & 0xFFF0) << 8) |\n                    ((val1 & 0x0F) << 8) | ((val2 & 0x0F) << 4) | (val3 & 0x0F);\n                color_flags = color_flags_a;\n                flag_mask = 21;\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    if (pixel_y == 2) {\n                        color_flags = color_flags_b;\n                        flag_mask = 21;\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++) {\n                        pixel = color_table_index +\n                            ((color_flags >> flag_mask) & 0x07);\n                        flag_mask -= 3;\n                        pixels[block_ptr++] = s->color_octets[pixel];\n                    block_ptr += row_inc;\n                ADVANCE_BLOCK();\n            n_blocks = (opcode & 0x0F) + 1;\n            while (n_blocks--) {\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++) {\n                        pixels[block_ptr++] = bytestream2_get_byte(gb);\n                    block_ptr += row_inc;\n                ADVANCE_BLOCK();\n    return 0;",
    "slice_lines": [
      76,
      93,
      94,
      113,
      114,
      123,
      126,
      127,
      129,
      131,
      132,
      133,
      136,
      137,
      141,
      142,
      143,
      150,
      153,
      154,
      155,
      156,
      160,
      161,
      162,
      164,
      166,
      167,
      168,
      169,
      170,
      171,
      173,
      174,
      176,
      183,
      184,
      187,
      188,
      189,
      190,
      194,
      195,
      196,
      197,
      198,
      200,
      202,
      203,
      205,
      207,
      208,
      209,
      210,
      211,
      213,
      214,
      216,
      217,
      218,
      220,
      221,
      223,
      230,
      231,
      233,
      234,
      235,
      236,
      237,
      239,
      241,
      248,
      251,
      254,
      255,
      256,
      257,
      260,
      261,
      263,
      264,
      266,
      268,
      269,
      270,
      271,
      272,
      273,
      274,
      275,
      277,
      278,
      279,
      281,
      283,
      290,
      293,
      296,
      297,
      298,
      299,
      302,
      303,
      305,
      306,
      308,
      310,
      311,
      313,
      314,
      315,
      316,
      317,
      318,
      319,
      320,
      322,
      324,
      331,
      334,
      337,
      338,
      339,
      340,
      343,
      344,
      346,
      347,
      349,
      351,
      359,
      360,
      361,
      362,
      363,
      364,
      366,
      368,
      369,
      370,
      372,
      373,
      374,
      376,
      377,
      378,
      379,
      380,
      382,
      384,
      391,
      393,
      394,
      395,
      396,
      397,
      399,
      401,
      407
    ],
    "metadata": {
      "original_data": {
        "tool_name": "codeql",
        "project_name": "ffmpeg",
        "project_name_with_version": "ffmpeg-6.1.1",
        "project_version": "6.1.1",
        "file_path": "libavcodec/smc.c",
        "line_number": 137,
        "cwe": null,
        "rule_id": "cpp/complex-block",
        "message": "Block with too many statements (7 complex statements in the block).",
        "severity": null
      },
      "function_name": "smc_decode_stream",
      "function_start_line": 76,
      "function_end_line": 408,
      "target_line": 137,
      "backward_nodes": 84,
      "forward_nodes": 474,
      "total_slice_nodes": 558,
      "total_slice_lines": 160,
      "slice_density": 0.4804804804804805,
      "final_node_count": 536
    }
  },
  {
    "project": "ffmpeg-6.1.1",
    "file": "libavcodec/vc1dec.c",
    "line": 483,
    "status": "success",
    "function_name": "<global>",
    "function_start_line": 1,
    "function_end_line": 1529,
    "sliced_code": "",
    "slice_lines": [],
    "metadata": {
      "original_data": {
        "tool_name": "codeql",
        "project_name": "ffmpeg",
        "project_name_with_version": "ffmpeg-6.1.1",
        "project_version": "6.1.1",
        "file_path": "libavcodec/vc1dec.c",
        "line_number": 483,
        "cwe": null,
        "rule_id": "cpp/complex-block",
        "message": "Block with too many statements (4 complex statements in the block).",
        "severity": null
      },
      "total_slice_lines": 0,
      "final_node_count": 0
    }
  },
  {
    "project": "ffmpeg-6.1.1",
    "file": "libavcodec/wavpackenc.c",
    "line": 2356,
    "status": "success",
    "function_name": "decorr_stereo_pass_id2",
    "function_start_line": 2350,
    "function_end_line": 2457,
    "sliced_code": "static void decorr_stereo_pass_id2(struct Decorr *dpp,\n    switch (dpp->value) { // CRITERION_LINE\n        for (i = 0; i < nb_samples; i++) {\n            sam = 2 * dpp->samplesA[0] - dpp->samplesA[1];\n            dpp->samplesA[1] = dpp->samplesA[0];\n            samples_l[i] = tmp = (dpp->samplesA[0] = samples_l[i]) - APPLY_WEIGHT_I(dpp->weightA, sam);\n            update_weight_d2(dpp->weightA, dpp->delta, sam, tmp);\n            sam = 2 * dpp->samplesB[0] - dpp->samplesB[1];\n            dpp->samplesB[1] = dpp->samplesB[0];\n            samples_r[i] = tmp = (dpp->samplesB[0] = samples_r[i]) - APPLY_WEIGHT_I(dpp->weightB, sam);\n            update_weight_d2(dpp->weightB, dpp->delta, sam, tmp);\n        for (i = 0; i < nb_samples; i++) {\n            sam = dpp->samplesA[0] + ((dpp->samplesA[0] - dpp->samplesA[1]) >> 1);\n            dpp->samplesA[1] = dpp->samplesA[0];\n            samples_l[i] = tmp = (dpp->samplesA[0] = samples_l[i]) - APPLY_WEIGHT_I(dpp->weightA, sam);\n            update_weight_d2(dpp->weightA, dpp->delta, sam, tmp);\n            sam = dpp->samplesB[0] + ((dpp->samplesB[0] - dpp->samplesB[1]) >> 1);\n            dpp->samplesB[1] = dpp->samplesB[0];\n            samples_r[i] = tmp = (dpp->samplesB[0] = samples_r[i]) - APPLY_WEIGHT_I(dpp->weightB, sam);\n            update_weight_d2(dpp->weightB, dpp->delta, sam, tmp);\n        for (m = 0, k = dpp->value & (MAX_TERM - 1), i = 0; i < nb_samples; i++) {\n            sam = dpp->samplesA[m];\n            samples_l[i] = tmp = (dpp->samplesA[k] = samples_l[i]) - APPLY_WEIGHT_I(dpp->weightA, sam);\n            update_weight_d2(dpp->weightA, dpp->delta, sam, tmp);\n            sam = dpp->samplesB[m];\n            samples_r[i] = tmp = (dpp->samplesB[k] = samples_r[i]) - APPLY_WEIGHT_I(dpp->weightB, sam);\n            update_weight_d2(dpp->weightB, dpp->delta, sam, tmp);\n            m = (m + 1) & (MAX_TERM - 1);\n            k = (k + 1) & (MAX_TERM - 1);\n        if (m) {\n            int32_t temp_A[MAX_TERM], temp_B[MAX_TERM];\n            memcpy(temp_A, dpp->samplesA, sizeof(dpp->samplesA));\n            memcpy(temp_B, dpp->samplesB, sizeof(dpp->samplesB));\n            for (k = 0; k < MAX_TERM; k++) {\n                dpp->samplesA[k] = temp_A[m];\n                dpp->samplesB[k] = temp_B[m];\n                m = (m + 1) & (MAX_TERM - 1);\n    case -1:\n        for (i = 0; i < nb_samples; i++) {\n            sam_A = dpp->samplesA[0];\n            samples_l[i] = tmp = (sam_B = samples_l[i]) - APPLY_WEIGHT_I(dpp->weightA, sam_A);\n            update_weight_clip_d2(dpp->weightA, dpp->delta, sam_A, tmp);\n            samples_r[i] = tmp = (dpp->samplesA[0] = samples_r[i]) - APPLY_WEIGHT_I(dpp->weightB, sam_B);\n            update_weight_clip_d2(dpp->weightB, dpp->delta, sam_B, tmp);\n    case -2:\n        for (i = 0; i < nb_samples; i++) {\n            sam_B = dpp->samplesB[0];\n            samples_r[i] = tmp = (sam_A = samples_r[i]) - APPLY_WEIGHT_I(dpp->weightB, sam_B);\n            update_weight_clip_d2(dpp->weightB, dpp->delta, sam_B, tmp);\n            samples_l[i] = tmp = (dpp->samplesB[0] = samples_l[i]) - APPLY_WEIGHT_I(dpp->weightA, sam_A);\n            update_weight_clip_d2(dpp->weightA, dpp->delta, sam_A, tmp);\n    case -3:\n        for (i = 0; i < nb_samples; i++) {\n            sam_A = dpp->samplesA[0];\n            sam_B = dpp->samplesB[0];\n            dpp->samplesA[0] = tmp = samples_r[i];\n            samples_r[i] = tmp -= APPLY_WEIGHT_I(dpp->weightB, sam_B);\n            update_weight_clip_d2(dpp->weightB, dpp->delta, sam_B, tmp);\n            dpp->samplesB[0] = tmp = samples_l[i];\n            samples_l[i] = tmp -= APPLY_WEIGHT_I(dpp->weightA, sam_A);\n            update_weight_clip_d2(dpp->weightA, dpp->delta, sam_A, tmp);",
    "slice_lines": [
      2350,
      2356,
      2358,
      2361,
      2362,
      2363,
      2364,
      2366,
      2367,
      2368,
      2369,
      2373,
      2376,
      2377,
      2378,
      2379,
      2381,
      2382,
      2383,
      2384,
      2388,
      2391,
      2392,
      2393,
      2395,
      2396,
      2397,
      2399,
      2400,
      2403,
      2404,
      2406,
      2407,
      2409,
      2410,
      2411,
      2412,
      2416,
      2417,
      2420,
      2421,
      2422,
      2424,
      2425,
      2428,
      2429,
      2432,
      2433,
      2434,
      2436,
      2437,
      2440,
      2441,
      2444,
      2445,
      2447,
      2448,
      2449,
      2451,
      2452,
      2453
    ],
    "metadata": {
      "original_data": {
        "tool_name": "codeql",
        "project_name": "ffmpeg",
        "project_name_with_version": "ffmpeg-6.1.1",
        "project_version": "6.1.1",
        "file_path": "libavcodec/wavpackenc.c",
        "line_number": 2356,
        "cwe": null,
        "rule_id": "cpp/complex-block",
        "message": "Block with too many statements (6 complex statements in the block).",
        "severity": null
      },
      "function_name": "decorr_stereo_pass_id2",
      "function_start_line": 2350,
      "function_end_line": 2457,
      "target_line": 2356,
      "backward_nodes": 2,
      "forward_nodes": 568,
      "total_slice_nodes": 570,
      "total_slice_lines": 61,
      "slice_density": 0.5648148148148148,
      "final_node_count": 590
    }
  }
]