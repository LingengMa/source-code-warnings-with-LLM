### **设计文档：基于 `match.py` 的告警生命周期追踪与状态标注**

#### 1. 目标

核心目标是扩展现有 `match.py` 的功能，使其能够处理 `input/data.json` 中包含多个项目和多个版本告警的数据集。系统需要追踪每个独立告警的生命周期，并根据其在不同版本间的匹配情况，最终将其分类为以下三种状态之一：

*   **True Positive (TP):** 真实告警。一个告警在某个版本中出现，但在后续所有版本中都消失了。这通常意味着该告警已被修复。
*   **False Positive (FP):** 误报。一个告警在某个版本中出现，并且在后续的至少一个版本中被成功匹配到。这表明该告警持续存在，可能是静态分析工具的误报。
*   **Unknown (未知):** 状态未知。一个告警出现在一个版本中，但该版本是此告警所在项目的最新版本。由于没有更后续的版本进行比较，我们无法确定它是被修复了还是会继续存在。

#### 2. 输入数据 (`input/data_with_id.json`) 结构分析

我们的分析将基于 `add_id_to_data.py` 脚本生成的 `input/data_with_id.json` 文件。该文件是包含告警信息的 JSON 数组，每个条目包含以下关键信息：

*   `id`: (新增) 每条告警的唯一标识符 (UUID)。
*   `project_name`: 项目名称 (例如, "ffmpeg")。
*   `project_version`: 项目的版本号 (例如, "6.1.1")。
*   `file_path`: 告警所在文件的相对路径。
*   `line_number`: 告警所在的行号。
*   以及其他告警元数据...

**告警类型说明**: 原始数据中缺少明确的告警类型字段 (如 `test_id`)。因此，在本次匹配实现中，我们将**不区分告警类型**进行匹配。这意味着，只要位置或代码内容相似，即使是不同类型的告警也可能被匹配到。这是一个为了处理当前数据而做的简化。

#### 3. 核心设计思路

我们将采用一种“按项目分组，按版本排序”的策略来处理数据。

1.  **数据预处理与分组**:
    *   读取 `input/data_with_id.json` 文件。
    *   将所有告警数据按 `project_name` 字段进行分组。

2.  **版本排序**:
    *   在每个项目分组内，根据 `project_version` 字段对所有版本进行排序。我们将使用语义化版本 (Semantic Versioning) 的规则来确保版本顺序的正确性。

3.  **告警生命周期追踪**:
    *   为每个独立告警创建一个全局追踪记录。这个记录将以告警的唯一 `id` 字段为索引。
    *   追踪记录将包含：
        *   `warning_object`: 完整的原始告警信息。
        *   `origin_version`: 告警首次出现的版本。
        *   `last_seen_version`: 告警最后一次被观察到的版本。
        *   `status`: 告警的当前状态，在迭代过程中可能被标记为 `FP`，默认为 `Unknown`。
        *   `history`: 一个记录该告警在版本间传递的匹配历史列表。

4.  **迭代匹配**:
    *   对于每个项目，我们将按版本顺序进行“一对多”的迭代匹配。
    *   其核心思想是：对于一个在版本 `V_i` 中出现的告警，必须检查其在**所有**后续版本 (`V_i+1`, `V_i+2`, ..., `V_n`) 中的状态。
    *   **具体流程**:
        1.  从版本 `V1` 开始，将其所有告警作为待追踪目标。
        2.  将 `V1` 的告警与 `V2`, `V3`, ..., `V_n` 逐一进行匹配。
        3.  如果一个 `V1` 的告警在**任何**一个后续版本中找到了匹配，则该告警的最终状态被确定为 **FP (False Positive)**。
        4.  如果一个 `V1` 的告警在**所有**后续版本中都**未**找到匹配，则其最终状态被确定为 **TP (True Positive)**。
        5.  处理完 `V1` 后，再处理 `V2` 中**新出现**的告警（即在 `V1` 中不存在的告警），将它们与 `V3`, `V4`, ..., `V_n` 进行比较，并遵循同样的逻辑判断其为 TP 或 FP。
        6.  以此类推，直到处理完 `V_n-1` 与 `V_n` 的比较。

5.  **最终状态确定**:
    *   经过上述迭代匹配后，每个告警的 TP 或 FP 状态就已经确定了。
    *   对于那些出现在项目最新版本 (`V_n`) 中的告警，由于没有更后续的版本可以进行比较，它们的状态将被标记为 **Unknown**。
    *   我们将汇总所有告警的原始信息及其最终被赋予的 `TP` / `FP` / `Unknown` 标签。

#### 4. `match.py` 的修改与扩展

为了实现上述逻辑，需要对 `match.py` 进行以下调整：

1.  **新增主控逻辑**:
    *   创建一个新的主函数或类（例如 `LifecycleTracker`），负责编排整个处理流程：数据加载、分组、排序、迭代匹配和结果生成。

2.  **引入版本排序工具**:
    *   集成一个库（如 `packaging.version`）来正确处理语义化版本号的排序。

3.  **修改 `Matcher` 类**:
    *   `Matcher` 类需要被调整，使其在匹配时**不再强制要求 `test_id` 相同**。
    *   `match_warnings_between_versions` 方法的输入将是两个版本的告警列表，而不是文件路径。

4.  **结果输出**:
    *   最终的输出应该是一个新的 JSON 文件（例如 `data_labeled.json`）。
    *   这个文件将包含 `input/data_with_id.json` 的所有原始条目，并为每个条目额外添加一个 `label` 字段，其值为 `TP`、`FP` 或 `Unknown`。

#### 5. 实现步骤概览

1.  **创建新文件 `tracker.py`**: 用于实现新的主控逻辑。
2.  **实现数据加载与预处理**: 在 `tracker.py` 中编写代码，读取 `data_with_id.json`，并按项目和版本进行组织。
3.  **实现版本排序**: 使用 `packaging.version` 对版本进行排序。
4.  **修改 `match.py`**: 移除 `Matcher` 类中各个匹配算法对 `test_id` 的依赖。
5.  **实现迭代匹配**: 在 `tracker.py` 中编写循环，调用修改后的 `Matcher` 类来比对版本。
6.  **实现最终状态判断逻辑**: 根据匹配结果确定每个告警的最终 `TP` / `FP` / `Unknown` 状态。
7.  **生成并保存结果**: 将标注好 `label` 的数据写回新的 JSON 文件。
